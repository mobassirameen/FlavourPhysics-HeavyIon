#ifndef __CINT__
#include "RooGlobalFunc.h"
#endif
#include "RooWorkspace.h"
#include "RooCategory.h"
#include "TKey.h"
#include "RooExponential.h"
#include <map>
#include "TCut.h"
#include "RooHistPdf.h"
#include "RooHist.h"
#include "TVirtualPad.h"
#include "RooDataHist.h"
#include <string>
#include "TEventList.h"
#include "RooFit.h"
#include "RooRealVar.h"
#include "TFile.h"
#include "RooDataSet.h"
#include "TTree.h"
#include "TH2D.h"
#include "RooPlot.h"
#include "TCanvas.h"
#include "TAxis.h"
#include "RooGaussian.h"
#include "RooGenericPdf.h"
#include "RooFitResult.h"
#include "RooAddPdf.h"
#include "RooAddition.h"
#include "RooAbsPdf.h"
#include "RooPolynomial.h"
#include "RooGaussModel.h"
#include "RooGaussian.h"
#include "RooChebychev.h"
#include "RooDecay.h"
#include "RooDataHist.h"
#include "RooAddModel.h"
#include "RooProdPdf.h"
#include "RooProduct.h"
#include "RooPlot.h"
#include "TH1D.h"
#include "TRandom.h"
#include "RooMinuit.h"
#include "RooExtendPdf.h"
#include "RooChi2Var.h"
#include "Math/Functor.h"
#include "TRandom3.h"
#include "Math/DistFunc.h"
#include "RooClassFactory.h"
#include "RooFitResult.h"
#include "RooDataSet.h"
#include "RooRealConstant.h"
#include "RooConstVar.h"
#include "Roo1DTable.h"
#include "RooBDecay.h"
#include "RooFormulaVar.h"
//#include "RoogmModel.h"
#include "RooRealSumPdf.h"
#include "Math/SpecFunc.h"
#include "RooBMixDecay.h"
#include "RooBCPEffDecay.h"
#include "Riostream.h"
#include "RooRandom.h"
#include "TMath.h"
/*#include "RooFun1TRPdf.h"
#include "RooFun2TRPdf.h"
#include "RooFun3TRPdf.h"
#include "RooFun4TRPdf.h"
#include "RooFun5TRPdf.h"
#include "RooFun6TRPdf.h"
#include "RooEffcthPdf.h"*/
#include "RooMCStudy.h"
#include "RooArgSet.h"
#include "RooLegendre.h"
#include "RooSpHarmonic.h"
#include "RooBifurGauss.h"
#include "complex.h"
#include <iostream>

using namespace RooFit; 
using namespace std;


void Hyperon_gr(){
    std::cout<<"======================="<<"\n";
    std::cout<<"========GR============="<<"\n";
    std::cout<<"======================="<<"\n";
    
    Int_t nbins = 20;
    std::cout<<" We have divided the whole q2 length in 20 bins and generate random numbers according Gaussian distribution"<<"\n";
    //cin>>nbins;
    //const Int_t nn = 10e6;
    // All Constant input values
    Double_t Mean_tau = 2.90e-10;
     Double_t ctau = 8.71;
    const double pi = 3.14159265358979323846;
    Double_t mxi = 1.31486, msigma = 1.18937, melectron = 0.000510999, mmuon = .1056583, mwboson = 80.385, msquark = 0.096, mupquark = 0.0022, mlepton;
    Double_t fermi_G = 0.000011663787, CKM_V = 0.2243;
    Double_t f3V = 0, f2A = 0, f1V =1.781, f2V = 2.113, f1A = 0.983, f3A = 5.241, sf = 0.0033;
    std::complex<Double_t> gleft (-1.05, 1.15);
    std::complex<Double_t> gright (0.04, 0.60);
    std::complex<Double_t> sright (-1.076, -0.809);
    std::complex<Double_t> sleft (-0.116, -0.788);
    //=================================================================================
    
    std::cout<<" The input of leton generation and the mass value : Only first and 2nd generation can be given as input"<<"\n"
    <<" For electron mass use melectron = 0.000510999 and for the muon mass use mmuon = .1056583"<<"\n";
    mlepton = melectron;
    //cin>>mlepton;
    // Variable need to be generated by Random
    //Double_t Q2sq[nn], asym1[nn], asym2[nn];
    Double_t minq2 = 0.0, maxq2 = 0.016, maxhel = 10.0, gaus_mean = 0.0075;
    Double_t q2, Qplus, Qminus, srQplus, srQminus, Pol_Ang, lifetime;
    Double_t h120s, h120p, h120v, h121v, h12tv, h120a, h121a, h12ta;
    Double_t SMh120s, SMh120p, SMh120v, SMh121v, SMh12tv, SMh120a, SMh121a, SMh12ta;
    Double_t modh121sq, modhm121sq, modh120sq, modhm12tsq, modh12tsq;//modhm12t=modhm120=(f1V+f1A)^2---close to maximum recoil
    Double_t hel_sq_1, hel_sq_2, hel_sq_3, hel_sq_4, hel_sq_5, hel_sq_6, hel_sq_7, hel_sq_8, hel_sq_9, hel_sq_10  ;
    Double_t SMhel_sq_1, SMhel_sq_2, SMhel_sq_3, SMhel_sq_4, SMhel_sq_5, SMhel_sq_6, SMhel_sq_7, SMhel_sq_8, SMhel_sq_9, SMhel_sq_10  ;
    Double_t Ampli_1,Ampli_2,Ampli_3,Ampli_4,Ampli_5,Ampli_6,Ampli_7,Ampli_8,Ampli_9, Total_Amplitude, ConsTant_Factor, Diff_Decay_Width,dGamma_Dq2;
    Double_t SMAmpli_1,SMAmpli_2,SMAmpli_3,SMAmpli_4,SMAmpli_5,SMAmpli_6,SMAmpli_7,SMAmpli_8,SMAmpli_9, SMTotal_Amplitude, SMConsTant_Factor, SMDiff_Decay_Width,SMdGamma_Dq2;
    Double_t AFB_Amp_1, AFB_Amp_2, AFB_Amp_3, AFB_Amp_4, AFB_Amp_5, AFB_Amp_6, AFB_Amp_7, AFB_Amp_8, AFB_Total_Amplitude, AFB_Numerator, AFB_Denominator, For_Back_Asymm;
    Double_t SMAFB_Amp_1, SMAFB_Amp_2, SMAFB_Amp_3, SMAFB_Amp_4, SMAFB_Amp_5, SMAFB_Amp_6, SMAFB_Amp_7, SMAFB_Amp_8, SMAFB_Total_Amplitude, SMAFB_Numerator, SMAFB_Denominator, SMFor_Back_Asymm;
    Double_t Convex_Amp_1, Convex_Amp_2, Convex_Amp_3, Convex_Amp_4, Convex_Amp_5, Convex_Total_Amplitude, Convexity_Parameter;
    Double_t SMConvex_Amp_1, SMConvex_Amp_2, SMConvex_Amp_3, SMConvex_Amp_4, SMConvex_Amp_5, SMConvex_Total_Amplitude, SMConvexity_Parameter;
    Double_t Had_Pol_Amp_1, Had_Pol_Amp_2, Had_Pol_Amp_3, Had_Pol_Amp_4, Had_Pol_Amp_5, Had_Pol_Amp_6, Resultant_Had_Pol, Hadronic_Polarization;
    Double_t SMHad_Pol_Amp_1, SMHad_Pol_Amp_2, SMHad_Pol_Amp_3, SMHad_Pol_Amp_4, SMHad_Pol_Amp_5, SMHad_Pol_Amp_6, SMResultant_Had_Pol, SMHadronic_Polarization;
    TRandom *grandom = new TRandom();
    TRandom *decay = new TRandom();
    
    auto  *helscalar0 =new TProfile("helscalar0", "scalar; q^{2} (GeV^{2}); Helicity Amplitudes (GeV^{2})", nbins, 0,maxq2,0,maxhel);
    auto  *helpseudoscalar0 =new TProfile("helpseudoscalar0", "scalar; q^{2} (GeV^{2}); Helicity Amplitudes (GeV^{2})", nbins, 0,maxq2, 0,maxhel);
    auto  *helvector01D = new TH1D("helvector01D", "Pseudo Scalar helicity", nbins, 0.0, maxhel);
    auto  *helvector0 = new TProfile("helvector0", "Vector helicity", nbins, 0.0,maxq2,0,maxhel );
    auto  *helvector1 = new TProfile("helvector1", "Vector helicity", nbins, 0.0,maxq2,0, maxhel);
    auto  *helvectort = new TProfile("helvectort", "Vector helicity", nbins, 0.0,maxq2,0, maxhel);
    auto  *helaxvector0 = new TProfile("helaxvector0", "Axial Vector helicity", nbins, 0.0,maxq2,0, maxhel);
    auto  *helaxvector1 = new TProfile("helaxvector1", "Axial Vector helicity", nbins, 0.0,maxq2,0, maxhel);
    auto  *helaxvectort = new TProfile("helaxvectort", "Axial Vector helicity", nbins, 0.0,maxq2,0, maxhel);
    
    
    
    
    
    auto  *diffAsFq2 = new TProfile("diffAsFq2", "DecayWidth as Function of q^{2}; q^{2} (GeV); d#Gamma/dq^{2}dcos#theta", nbins, 0.0,maxq2,0,0.001);
    auto  *SMdiffAsFq2 = new TProfile("SMdiffAsFq2", "DecayWidth as Function of q^{2}; q^{2} (GeV); d#Gamma/dq^{2}dcos#theta", nbins, 0.0,maxq2,0,0.001);
    auto  *diffAsFthet = new TProfile("diffAsFthet", "DecayWidth as Function of #theta_{l}; #theta_{l} (rad); d#Gamma/dq^{2}dcos#theta", nbins, -TMath::Pi(),TMath::Pi(),0,pow(10,-17));
    auto  *AFBAsFq2 = new TProfile("AFBAsFq2", "FB asymmetry as Function of q^{2}; q^{2} (GeV); A_{FB}", nbins, 0.0,maxq2,-1,1);
    auto  *SMAFBAsFq2 = new TProfile("SMAFBAsFq2", "FB asymmetry as Function of q^{2}; q^{2} (GeV); A_{FB}", nbins, 0.0,maxq2,1,1);
    auto  *ConAsFq2 = new TProfile("ConAsFq2", "Convexity parameter  as Function of q^{2}; q^{2} (GeV); Convexity", nbins, 0.0,maxq2,-0.5,0.5);
    auto  *SMConAsFq2 = new TProfile("SMConAsFq2", "Convexity parameter  as Function of q^{2}; q^{2} (GeV); Convexity", nbins, 0.0,maxq2,-0.5,0.5);
    auto  *HadPolAsFq2 = new TProfile("HadPolAsFq2", "Hadronic polarization  as Function of q^{2}; q^{2} (GeV); Hadronic Polarization", nbins, 0.0,maxq2,-1.0,1.0);
    auto  *SMHadPolAsFq2 = new TProfile("SMHadPolAsFq2", "Hadronic polarization  as Function of q^{2}; q^{2} (GeV); Hadronic Polarization", nbins, 0.0,maxq2,-1.0,1.0);
    auto  *BRFracAsFq2 = new TProfile("BRFracAsFq2", "BR fraction   as Function of q^{2}; q^{2} (GeV); BR", nbins, 0.0,maxq2,0, 1e-8);
    auto  *SMBRFracAsFq2 = new TProfile("SMBRFracAsFq2", "BR fraction   as Function of q^{2}; q^{2} (GeV); BR", nbins, 0.0,maxq2,0, 1e-8);
    auto *polarhad = new TH1D("polarhad", "polarhad", nbins, 0.0, 1);
    auto *branfrac = new TH1D("branfrac", "branfrac", nbins, 0.0, 1e-8);
    auto *afbasymm = new TH1D("afbasymm", "afbasymm", nbins, 0.0, 1);
    auto *convexityhist = new TH1D("convexityhist", "convexityhist", nbins, 0.0, 1);
  
    
    
    
      for( Int_t i=0 ; i< 1000000; ++i){
          q2 = grandom->Gaus(gaus_mean,maxq2);//Gaus(mean,sigma)
         //Q2sq[i] = q2;
          Qplus = (mxi+msigma)*(mxi+msigma) - q2;
        Qminus = (mxi-msigma)*(mxi-msigma) - q2;
        srQplus = sqrt(Qplus);
        srQminus = sqrt(Qminus);
//=================================================================================================================Helicity Amplitudes
        h120s = abs(0.0*(real(sleft)+real(sright))*(srQplus/(msquark-mupquark))*((mxi-msigma)*f1V + (q2/mxi)*f3V));
        h120p = abs(0.0*(real(sleft)-real(sright))*(srQminus/(msquark+mupquark))*(-(mxi+msigma)*f1A + (q2/mxi)*f3A));
          h120v = abs((1.0+real(gright))*(srQminus/sqrt(q2))*((mxi+msigma)*f1V + (q2/mxi)*f2V));
          h121v = abs((1.0+real(gright))*(sqrt(2.0)*srQminus)*(-f1V - ((mxi+msigma)/mxi)*f2V));
          h12tv = abs((1.0+real(gright))*(srQplus/sqrt(q2))*((mxi-msigma)*f1V + (q2/mxi)*f3V));
          h120a = abs((1.0-real(gright))*(srQplus/sqrt(q2))*(-(mxi-msigma)*f1A + (q2/mxi)*f2A));
          h121a = abs((1.0-real(gright))*(sqrt(2.0)*srQplus)*(f1A - ((mxi-msigma)/mxi)*f2A));
          h12ta = abs((1.0-real(gright))*(srQminus/sqrt(q2))*(-(mxi+msigma)*f1A + (q2/mxi)*f3A));
        modh121sq = (h121v+h121a)*(h121v+h121a);
        modhm121sq = (h121v-h121a)*(h121v-h121a);
        modh120sq = (h120v+h120a)*(h120v+h120a);
        modhm12tsq = (f1V+f1A)*(f1V+f1A);
        modh12tsq = (h12tv+h12ta)*(h12tv+h12ta);
          
          
          
          if((h120s == h120s) &&(h120v == h120v) && (h121v == h121v) &&(h12tv == h12tv) && (h120a == h120a) && (h121a == h121a) && (h12ta == h12ta)){
//=====================================================================================================
          // Square and multiplication of helicity amplitudes
          // to calculate the actual amplitudes in described in the model
//====================================================================================
          
          
          hel_sq_1 = pow((h121v+h121a),2);
          hel_sq_2 = pow((h121v-h121a),2);
          hel_sq_3 = pow((h120v+h120a),2);
          hel_sq_4 = pow((h120v+h120a),2);
          hel_sq_5 = pow((h12tv+h12ta),2);
          hel_sq_6 = pow((h12tv+h12ta),2);
          hel_sq_7 = (h12tv+h12ta)*(h120v+h120a)+(h12tv+h12ta)*(h120v+h120a);
          hel_sq_8 = pow((h120s+h120p),2);
          hel_sq_9 = (h120v+h120a)*(h120s+h120p)+(h120v+h120a)*(h120s+h120p);
          hel_sq_10 = (h12tv+h12ta)*(h120s+h120p)+(h12tv+h12ta)*(h120s+h120p);
         
         
          Pol_Ang = grandom->Gaus(-0.785, 6.28);
          Ampli_1 = (1.0/4.0)*(((1+cos(Pol_Ang))*(1+cos(Pol_Ang))*hel_sq_1) + ((1-cos(Pol_Ang))*(1-cos(Pol_Ang))*hel_sq_2));
          Ampli_2 = (1.0/2.0)*sin(Pol_Ang)*(hel_sq_3+hel_sq_4);
          Ampli_3 = ((mlepton*mlepton)/(2.0*q2))*(hel_sq_5+hel_sq_6);
          Ampli_4 = ((mlepton*mlepton*sin(Pol_Ang)*sin(Pol_Ang))/(4.0*q2))*(hel_sq_1+hel_sq_2);
          Ampli_5 = ((mlepton*mlepton*cos(Pol_Ang)*cos(Pol_Ang))/(2.0*q2))*(hel_sq_3+hel_sq_4);
          Ampli_6 = -((mlepton*mlepton*cos(Pol_Ang)*cos(Pol_Ang))/(q2))*hel_sq_7;
          Ampli_7 = (2.0)*(hel_sq_8+hel_sq_8);
          Ampli_8 = -((4.0)*mlepton*cos(Pol_Ang)/(sqrt(q2)))*hel_sq_9;
          Ampli_9 = (((4.0)*mlepton)/(sqrt(q2)))*hel_sq_10;
          Total_Amplitude = Ampli_1+Ampli_2+Ampli_3+Ampli_4+Ampli_5+Ampli_6+Ampli_7+Ampli_8+Ampli_9;
          ConsTant_Factor = (fermi_G*fermi_G*CKM_V*CKM_V)/(pow(((2.0)*pi),3)*64.0*mxi*mxi);
          Diff_Decay_Width = ConsTant_Factor*(1.0/2.0*mxi)*sqrt(Qplus*Qminus)*(1-(mlepton*mlepton/q2))*(q2-mlepton*mlepton)*Total_Amplitude;
          diffAsFq2->Fill(q2,Diff_Decay_Width,1);
          diffAsFthet->Fill(Pol_Ang,Diff_Decay_Width,1);
          
 //================================================================================
          // dGamma/dq2
          // Forward - Backward Asymmetry
          //===================================
          
          
          
          AFB_Amp_1 = (1.0/6.0)*(hel_sq_1+hel_sq_2);
          AFB_Amp_2 = (1.0/3.0)*(hel_sq_3 +hel_sq_4);
          AFB_Amp_3 = ((mlepton*mlepton)/(2.0*q2))*(hel_sq_5+hel_sq_6);
          AFB_Amp_4 = ((mlepton*mlepton*pi)/(16.0*q2))*(hel_sq_5+hel_sq_2);
          AFB_Amp_5 = ((mlepton*mlepton*2.0)/(6.0*q2))*(hel_sq_3+hel_sq_4);
          AFB_Amp_6 = ((mlepton*mlepton*2.0)/(3.0*q2))*(hel_sq_7);
          AFB_Amp_7 = 4.0*hel_sq_8;
          AFB_Amp_8 = ((8.0*mlepton)/sqrt(q2))*(hel_sq_10);
          AFB_Total_Amplitude = AFB_Amp_1+AFB_Amp_2+AFB_Amp_3+AFB_Amp_4+AFB_Amp_5+AFB_Amp_6+AFB_Amp_7+AFB_Amp_8;
          AFB_Numerator = (1.0/2.0)*(hel_sq_1-hel_sq_2)+((4.0*mlepton)/(sqrt(q2)))*(hel_sq_9);
          AFB_Denominator =AFB_Total_Amplitude;
          For_Back_Asymm = AFB_Numerator/AFB_Denominator;
          AFBAsFq2->Fill(q2, For_Back_Asymm,1);
          dGamma_Dq2 = ConsTant_Factor*(1/2.0*mxi)*sqrt(Qplus*Qminus)*(1-(mlepton*mlepton/q2))*(q2-mlepton*mlepton)*AFB_Total_Amplitude;
          afbasymm->Fill(For_Back_Asymm);
          branfrac->Fill(dGamma_Dq2/Mean_tau);
          BRFracAsFq2->Fill(q2,(dGamma_Dq2/Mean_tau),1);
          
//================================================================================================
          // Convexity parameter
          //====================================
          
          
          
          Convex_Amp_1 = (1.0/2.0)*(hel_sq_1+hel_sq_2);
          Convex_Amp_2 = -(1.0/2.0*pow(sin(Pol_Ang), 3))*(hel_sq_3 + hel_sq_4);
          Convex_Amp_3 = -(1.0*mlepton*mlepton/4.0*q2*pow(sin(Pol_Ang),3))*(hel_sq_1+hel_sq_2);
          Convex_Amp_4 = (mlepton*mlepton/q2)*(hel_sq_3+hel_sq_4);
          Convex_Amp_5 = -(2.0*mlepton*mlepton/q2)*(hel_sq_7);
          
          Convex_Total_Amplitude = Convex_Amp_1+Convex_Amp_2+Convex_Amp_3+Convex_Amp_4+Convex_Amp_5;
          Convexity_Parameter = Convex_Total_Amplitude/AFB_Denominator;
          convexityhist->Fill(Convexity_Parameter);
          ConAsFq2->Fill(q2, Convexity_Parameter,1);
          
          
          //========================================================
          //Hadron Polarization
          //===================================
          
          
          
          Had_Pol_Amp_1 = ((1.0/6.0)*hel_sq_1) + ((1.0/3.0)*hel_sq_3) + ((mlepton*mlepton/2.0*q2)*hel_sq_5) + (((mlepton*mlepton*pi)/16.0*q2)*hel_sq_1);
          Had_Pol_Amp_2 = (((mlepton*mlepton*2.0)/(6.0*q2))*hel_sq_3) - (((mlepton*mlepton*2.0)/3.0*q2)*(h12tv+h12ta)*(h120v+h120a)) ;
          Had_Pol_Amp_3 = (4.0*hel_sq_8) + (((8.0*mlepton)/sqrt(q2))*(h120v+h120a)*(h120s+h120p)) ;
          
          Had_Pol_Amp_4 = ((1.0/6.0)*hel_sq_2) + ((1.0/3.0)*hel_sq_4) + ((mlepton*mlepton/2.0*q2)*hel_sq_6) + (((mlepton*mlepton*pi)/16.0*q2)*hel_sq_2);
          Had_Pol_Amp_5 = (((mlepton*mlepton*2.0)/(6.0*q2))*hel_sq_4) - (((mlepton*mlepton*2.0)/3.0*q2)*(h12tv+h12ta)*(h120v+h120a)) ;
          Had_Pol_Amp_6 = (4.0*hel_sq_8) + (((8.0*mlepton)/sqrt(q2))*(h12tv+h12ta)*(h120s+h120p)) ;
          
          Resultant_Had_Pol = (Had_Pol_Amp_1+Had_Pol_Amp_2+Had_Pol_Amp_3)-(Had_Pol_Amp_4+Had_Pol_Amp_5+Had_Pol_Amp_6);
          Hadronic_Polarization = (ConsTant_Factor*(1/2.0*mxi)*sqrt(Qplus*Qminus)*(1-(mlepton*mlepton/q2))*(q2-mlepton*mlepton)*Resultant_Had_Pol)/(dGamma_Dq2) ;
          HadPolAsFq2->Fill(q2, Hadronic_Polarization,1);
          polarhad->Fill(Hadronic_Polarization);
          
          }
          
//===============================================================================================================================================================
          //Standard Model
          
          
          
          SMh120v = abs((1.0)*(srQminus/sqrt(q2))*((mxi+msigma)*f1V + (q2/mxi)*f2V));
          SMh121v = abs((1.0)*(sqrt(2.0)*srQminus)*(-f1V - ((mxi+msigma)/mxi)*f2V));
          SMh12tv = abs((1.0)*(srQplus/sqrt(q2))*((mxi-msigma)*f1V + (q2/mxi)*f3V));
          SMh120a = abs((1.0)*(srQplus/sqrt(q2))*(-(mxi-msigma)*f1A + (q2/mxi)*f2A));
          SMh121a = abs((1.0)*(sqrt(2.0)*srQplus)*(f1A - ((mxi-msigma)/mxi)*f2A));
          SMh12ta = abs((1.0)*(srQminus/sqrt(q2))*(-(mxi+msigma)*f1A + (q2/mxi)*f3A));
          
         
          if((SMh120v == SMh120v)&&(SMh121v == SMh121v)&&(SMh12tv == SMh12tv) &&(SMh120a == SMh120a) &&(SMh121a == SMh121a)&&(SMh121a == SMh121a) &&(SMh12ta == SMh12ta)){
          
          SMhel_sq_1 = pow((SMh121v+SMh121a),2);
          SMhel_sq_2 = pow((SMh121v-SMh121a),2);
          SMhel_sq_3 = pow((SMh120v+SMh120a),2);
          SMhel_sq_4 = pow((SMh120v+SMh120a),2);
          SMhel_sq_5 = pow((SMh12tv+SMh12ta),2);
          SMhel_sq_6 = pow((SMh12tv+SMh12ta),2);
          SMhel_sq_7 = (SMh12tv+SMh12ta)*(SMh120v+SMh120a)+(SMh12tv+SMh12ta)*(SMh120v+SMh120a);
          
          SMAmpli_1 = (1.0/4.0)*(((1+cos(Pol_Ang))*(1+cos(Pol_Ang))*SMhel_sq_1) + ((1-cos(Pol_Ang))*(1-cos(Pol_Ang))*SMhel_sq_2));
          SMAmpli_2 = (1.0/2.0)*sin(Pol_Ang)*(SMhel_sq_3+SMhel_sq_4);
          SMAmpli_3 = ((mlepton*mlepton)/(2.0*q2))*(SMhel_sq_5+SMhel_sq_6);
          SMAmpli_4 = ((mlepton*mlepton*sin(Pol_Ang)*sin(Pol_Ang))/(4.0*q2))*(SMhel_sq_1+SMhel_sq_2);
          SMAmpli_5 = ((mlepton*mlepton*cos(Pol_Ang)*cos(Pol_Ang))/(2.0*q2))*(SMhel_sq_3+SMhel_sq_4);
          SMAmpli_6 = -((mlepton*mlepton*cos(Pol_Ang)*cos(Pol_Ang))/(q2))*SMhel_sq_7;
          SMTotal_Amplitude = SMAmpli_1+SMAmpli_2+SMAmpli_3+SMAmpli_4+SMAmpli_5+SMAmpli_6;
          SMConsTant_Factor = (fermi_G*fermi_G*CKM_V*CKM_V)/(pow(((2.0)*pi),3)*64.0*mxi*mxi);
          SMDiff_Decay_Width = SMConsTant_Factor*(1.0/2.0*mxi)*sqrt(Qplus*Qminus)*(1-(mlepton*mlepton/q2))*(q2-mlepton*mlepton)*SMTotal_Amplitude;
          SMdiffAsFq2->Fill(q2,SMDiff_Decay_Width,1);
          
          
          SMAFB_Amp_1 = (1.0/6.0)*(SMhel_sq_1+SMhel_sq_2);
          SMAFB_Amp_2 = (1.0/3.0)*(SMhel_sq_3 +SMhel_sq_4);
          SMAFB_Amp_3 = ((mlepton*mlepton)/(2.0*q2))*(SMhel_sq_5+SMhel_sq_6);
          SMAFB_Amp_4 = ((mlepton*mlepton*pi)/(16.0*q2))*(SMhel_sq_5+SMhel_sq_2);
          SMAFB_Amp_5 = ((mlepton*mlepton*2.0)/(6.0*q2))*(SMhel_sq_3+SMhel_sq_4);
          SMAFB_Amp_6 = ((mlepton*mlepton*2.0)/(3.0*q2))*(SMhel_sq_7);
          SMAFB_Total_Amplitude = SMAFB_Amp_1+SMAFB_Amp_2+SMAFB_Amp_3+SMAFB_Amp_4+SMAFB_Amp_5+SMAFB_Amp_6;
          SMAFB_Numerator = (1.0/2.0)*(SMhel_sq_1-SMhel_sq_2);
          SMAFB_Denominator =SMAFB_Total_Amplitude;
          SMFor_Back_Asymm = SMAFB_Numerator/SMAFB_Denominator;
          SMAFBAsFq2->Fill(q2, SMFor_Back_Asymm,1);
          SMdGamma_Dq2 = SMConsTant_Factor*(1/2.0*mxi)*sqrt(Qplus*Qminus)*(1-(mlepton*mlepton/q2))*(q2-mlepton*mlepton)*SMAFB_Total_Amplitude;
          SMBRFracAsFq2->Fill(q2,(SMdGamma_Dq2/Mean_tau),1);
          
          
          SMConvex_Amp_1 = (1.0/2.0)*(SMhel_sq_1+SMhel_sq_2);
          SMConvex_Amp_2 = -(1.0/2.0*pow(sin(Pol_Ang), 3))*(SMhel_sq_3 + SMhel_sq_4);
          SMConvex_Amp_3 = -(1.0*mlepton*mlepton/4.0*q2*pow(sin(Pol_Ang),3))*(SMhel_sq_1+SMhel_sq_2);
          SMConvex_Amp_4 = (mlepton*mlepton/q2)*(SMhel_sq_3+SMhel_sq_4);
          SMConvex_Amp_5 = -(2.0*mlepton*mlepton/q2)*(SMhel_sq_7);
          SMConvex_Total_Amplitude = SMConvex_Amp_1+SMConvex_Amp_2+SMConvex_Amp_3+SMConvex_Amp_4+SMConvex_Amp_5;
          SMConvexity_Parameter = SMConvex_Total_Amplitude/SMAFB_Denominator;
          SMConAsFq2->Fill(q2, SMConvexity_Parameter,1);
          
          SMHad_Pol_Amp_1 = ((1.0/6.0)*SMhel_sq_1) + ((1.0/3.0)*SMhel_sq_3) + ((mlepton*mlepton/2.0*q2)*SMhel_sq_5) + (((mlepton*mlepton*pi)/16.0*q2)*SMhel_sq_1);
          SMHad_Pol_Amp_2 = (((mlepton*mlepton*2.0)/(6.0*q2))*SMhel_sq_3) - (((mlepton*mlepton*2.0)/3.0*q2)*(SMh12tv+SMh12ta)*(SMh120v+SMh120a)) ;
          SMHad_Pol_Amp_4 = ((1.0/6.0)*SMhel_sq_2) + ((1.0/3.0)*SMhel_sq_4) + ((mlepton*mlepton/2.0*q2)*SMhel_sq_6) + (((mlepton*mlepton*pi)/16.0*q2)*SMhel_sq_2);
          SMHad_Pol_Amp_5 = (((mlepton*mlepton*2.0)/(6.0*q2))*SMhel_sq_4) - (((mlepton*mlepton*2.0)/3.0*q2)*(SMh12tv+SMh12ta)*(SMh120v+SMh120a)) ;
          SMResultant_Had_Pol = (SMHad_Pol_Amp_1+SMHad_Pol_Amp_2)-(SMHad_Pol_Amp_4+SMHad_Pol_Amp_5);
          SMHadronic_Polarization = (SMConsTant_Factor*(1/2.0*mxi)*sqrt(Qplus*Qminus)*(1-(mlepton*mlepton/q2))*(q2-mlepton*mlepton)*SMResultant_Had_Pol)/(SMdGamma_Dq2) ;
          SMHadPolAsFq2->Fill(q2, SMHadronic_Polarization,1);
          
          }
          
        helscalar0->Fill(q2,h120s,1);
        helpseudoscalar0->Fill(q2, h120p, 1);
        helvector0->Fill(q2, h120v, 1);
        helvector1->Fill(q2, h121v, 1);
        helvectort->Fill(q2, h12tv, 1);
        helaxvector0->Fill(q2, h120a, 1);
        helaxvector1->Fill(q2, h121a, 1);
        helaxvectort->Fill(q2, h12ta, 1);
        
        
        
        
       
          
          
          
          
          
          
          
        
          
        
    }
   
    
    
    std::cout<<"smhad"<<Hadronic_Polarization<<"\t"<<SMHadronic_Polarization<<"\n";
    std::cout <<" Hadron polarization  : "<<polarhad->GetRMS()<<" pm "<<polarhad->GetRMSError()<<"\n";
    std::cout<<"Differential branching ratio:  "<<branfrac->GetRMS()<<"pm"<<branfrac->GetRMSError()<<"\n";
    std::cout<<"The value of the differential decay width costheta integrated:  "<<dGamma_Dq2<<"\n";
    std::cout<<"The value of the differential decay width:  "<<Diff_Decay_Width<<"\n";
    std::cout<<"Forward -Backward asymmetry:  "<<afbasymm->GetRMS()<<"pm"<<afbasymm->GetRMSError()<<"\n";
    std::cout<<"Convexity parameter:  "<<convexityhist->GetRMS()<<"pm"<<convexityhist->GetRMSError()<<"\n";
    TCanvas * c = new TCanvas();
    helvector0->Draw();
    helvector0->SetMarkerStyle(8);
    helvector0->SetMarkerColor(8);
    helvector1->Draw("same");
    helvector1->SetMarkerStyle(21);
    helvector1->SetMarkerColor(4);
    helvectort->Draw("same");
    helvectort->SetMarkerStyle(33);
    helvectort->SetMarkerColor(9);
    helaxvector0->Draw("same");
    helaxvector0->SetMarkerStyle(34);
    helaxvector0->SetMarkerColor(28);
    helaxvector1->Draw("same");
    helaxvector1->SetMarkerStyle(22);
    helaxvector1->SetMarkerColor(2);
    helaxvectort->Draw("same");
    helaxvectort->SetMarkerStyle(23);
    helaxvectort->SetMarkerColor(1);
    TLegend *legend = new TLegend(0.01,0.4,0.014,0.5);
    legend->SetHeader("only g_{R}","C");
    legend->AddEntry(helvector0, "H_{#frac{1}{2}0}^{V}");
    legend->AddEntry(helvector1, "H_{#frac{1}{2}1}^{V}");
    legend->AddEntry(helvectort, "H_{#frac{1}{2}t}^{V}");
    legend->AddEntry(helaxvector0, "H_{#frac{1}{2}0}^{A}");
    legend->AddEntry(helaxvector1, "H_{#frac{1}{2}1}^{A}");
    legend->AddEntry(helaxvectort, "H_{#frac{1}{2}t}^{A}");
    legend->Draw();
    
    TCanvas * c1 = new TCanvas();
    diffAsFq2->Draw();
    SMdiffAsFq2->Draw("same");
    diffAsFq2->SetMarkerStyle(22);
    diffAsFq2->SetMarkerColor(2);
    SMdiffAsFq2->SetMarkerStyle(23);
    SMdiffAsFq2->SetMarkerColor(1);
    TLegend *legend1 = new TLegend(0.01,0.4,0.014,0.5);
    legend1->AddEntry(diffAsFq2, "Only g_{R}");
    legend1->AddEntry(SMdiffAsFq2, "SM");
    legend1->Draw();
    TCanvas * c2 = new TCanvas();
    gStyle->SetPalette(1);
    diffAsFthet->Draw();
    
    TCanvas * c3 = new TCanvas();
    AFBAsFq2->Draw();
    SMAFBAsFq2->Draw("same");
    AFBAsFq2->SetMarkerStyle(22);
    AFBAsFq2->SetMarkerColor(2);
    SMAFBAsFq2->SetMarkerStyle(23);
    SMAFBAsFq2->SetMarkerColor(1);
    TLegend *legend2 = new TLegend(0.01,0.4,0.014,0.5);
    legend2->AddEntry(AFBAsFq2, "Only g_{R}");
    legend2->AddEntry(SMAFBAsFq2, "SM");
    legend2->Draw();
    
    TCanvas * c4 = new TCanvas();
    ConAsFq2->Draw();
    SMConAsFq2->Draw("same");
    ConAsFq2->SetMarkerStyle(22);
    ConAsFq2->SetMarkerColor(2);
    SMConAsFq2->SetMarkerStyle(23);
    SMConAsFq2->SetMarkerColor(1);
    TLegend *legend3 = new TLegend(0.01,0.4,0.014,0.5);
    legend3->AddEntry(ConAsFq2, "Only g_{R}");
    legend3->AddEntry(SMConAsFq2, "SM");
    legend3->Draw();
    
    TCanvas * c5 = new TCanvas();
    HadPolAsFq2->Draw();
    SMHadPolAsFq2->Draw("same");
    HadPolAsFq2->SetMarkerStyle(22);
    HadPolAsFq2->SetMarkerColor(2);
    SMHadPolAsFq2->SetMarkerStyle(23);
    SMHadPolAsFq2->SetMarkerColor(1);
    TLegend *legend4 = new TLegend(0.01,0.4,0.014,0.5);
    legend4->AddEntry(HadPolAsFq2, "Only g_{R}");
    legend4->AddEntry(SMHadPolAsFq2, "SM");
    legend4->Draw();
    
    TCanvas * c6 = new TCanvas();
    BRFracAsFq2->Draw();
    SMBRFracAsFq2->Draw("same");
    BRFracAsFq2->SetMarkerStyle(22);
    BRFracAsFq2->SetMarkerColor(2);
    SMBRFracAsFq2->SetMarkerStyle(23);
    SMBRFracAsFq2->SetMarkerColor(1);
    TLegend *legend5 = new TLegend(0.01,0.4,0.014,0.5);
    legend5->AddEntry(BRFracAsFq2, "Only g_{R}");
    legend5->AddEntry(SMBRFracAsFq2, "SM");
    legend5->Draw();
    
    
}
