#ifndef __CINT__
#include "RooGlobalFunc.h"
#endif
#include "RooWorkspace.h"
#include "RooCategory.h"
#include "TKey.h"
#include "RooExponential.h"
#include <map>
#include "TCut.h"
#include "RooHistPdf.h"
#include "RooHist.h"
#include "TVirtualPad.h"
#include "RooDataHist.h"
#include <string>
#include "TEventList.h"
#include "RooFit.h"
#include "RooRealVar.h"
#include "TFile.h"
#include "RooDataSet.h"
#include "TTree.h"
#include "TH2D.h"
#include "RooPlot.h"
#include "TCanvas.h"
#include "TAxis.h"
#include "RooGaussian.h"
#include "RooGenericPdf.h"
#include "RooFitResult.h"
#include "RooAddPdf.h"
#include "RooAddition.h"
#include "RooAbsPdf.h"
#include "RooPolynomial.h"
#include "RooGaussModel.h"
#include "RooGaussian.h"
#include "RooChebychev.h"
#include "RooDecay.h"
#include "RooDataHist.h"
#include "RooAddModel.h"
#include "RooProdPdf.h"
#include "RooProduct.h"
#include "RooPlot.h"
#include "TH1D.h"
#include "TRandom.h"
#include "RooMinuit.h"
#include "RooExtendPdf.h"
#include "RooChi2Var.h"
#include "Math/Functor.h"
#include "TRandom3.h"
#include "Math/DistFunc.h"
#include "RooClassFactory.h"
#include "RooFitResult.h"
#include "RooDataSet.h"
#include "RooRealConstant.h"
#include "RooConstVar.h"
#include "Roo1DTable.h"
#include "RooBDecay.h"
#include "RooFormulaVar.h"
//#include "RoogmModel.h"
#include "RooRealSumPdf.h"
#include "Math/SpecFunc.h"
#include "RooBMixDecay.h"
#include "RooBCPEffDecay.h"
#include "Riostream.h"
#include "RooRandom.h"
#include "TMath.h"
/*#include "RooFun1TRPdf.h"
#include "RooFun2TRPdf.h"
#include "RooFun3TRPdf.h"
#include "RooFun4TRPdf.h"
#include "RooFun5TRPdf.h"
#include "RooFun6TRPdf.h"
#include "RooEffcthPdf.h"*/
#include "RooMCStudy.h"
#include "RooArgSet.h"
#include "RooLegendre.h"
#include "RooSpHarmonic.h"
#include "RooBifurGauss.h"
#include "complex.h"
#include <iostream>

using namespace RooFit; 
using namespace std;


void Hyperon(){
    std::cout<<cos(3.14)<<"\n";
    Int_t nbins;
    std::cout<<" Bin value"<<"\n";
    cin>>nbins;
    // All Constant input values
    Double_t Mean_tau = 2.90e-10;
     Double_t ctau = 8.71;
    const double pi = 3.14159265358979323846;
    Double_t mxi = 1.31486, msigma = 1.18937, melectron = 0.000510999, mmuon = .1056583, mwboson = 80.385, msquark = 0.096, mupquark = 0.0022, mlepton;
    Double_t fermi_G = 0.000011663787, CKM_V = 0.2243;
    Double_t f3V = 0, f2A = 0, f1V =1.781, f2V = 2.113, f1A = 0.983, f3A = 5.241;
    std::complex<Double_t> gleft (-1.05, 1.15);
    std::complex<Double_t> gright (0.04, 0.60);
    std::complex<Double_t> sright (-1.076, -0.809);
    std::complex<Double_t> sleft (-0.116, -0.788);
    //=================================================================================
    
    std::cout<<" The input of leton generation and the mass value : Only first and 2nd generation can be given as input"<<"\n"
    <<" For electron mass use melectron = 0.000510999 and for the muon mass use mmuon = .1056583"<<"\n";
    mlepton = melectron;
    //cin>>mlepton;
    // Variable need to be generated by Random
    Double_t q2, Qplus, Qminus, srQplus, srQminus, Pol_Ang, lifetime;
    Double_t h120s, h120p, h120v, h121v, h12tv, h120a, h121a, h12ta;
    Double_t modh121sq, modhm121sq, modh120sq, modhm12tsq, modh12tsq;//modhm12t=modhm120=(f1V+f1A)^2---close to maximum recoil
    Double_t hel_sq_1, hel_sq_2, hel_sq_3, hel_sq_4, hel_sq_5, hel_sq_6, hel_sq_7, hel_sq_8, hel_sq_9, hel_sq_10  ;
    Double_t Ampli_1,Ampli_2,Ampli_3,Ampli_4,Ampli_5,Ampli_6,Ampli_7,Ampli_8,Ampli_9, Total_Amplitude, ConsTant_Factor, Diff_Decay_Width,dGamma_Dq2;
    Double_t AFB_Amp_1, AFB_Amp_2, AFB_Amp_3, AFB_Amp_4, AFB_Amp_5, AFB_Amp_6, AFB_Amp_7, AFB_Amp_8, AFB_Total_Amplitude, AFB_Numerator, AFB_Denominator, For_Back_Asymm;
    Double_t Convex_Amp_1, Convex_Amp_2, Convex_Amp_3, Convex_Amp_4, Convex_Amp_5, Convex_Total_Amplitude, Convexity_Parameter;
    Double_t Had_Pol_Amp_1, Had_Pol_Amp_2, Had_Pol_Amp_3, Had_Pol_Amp_4, Had_Pol_Amp_5, Had_Pol_Amp_6, Resultant_Had_Pol, Hadronic_Polarization;
    TRandom *grandom = new TRandom();
    TRandom *decay = new TRandom();
    
    auto  *helscalar0 =new TProfile("helscalar0", "scalar; q^{2} (GeV^{2}); Helicity Amplitudes (GeV^{2})", nbins, 0,0.015,0,0.6);
    auto  *helpseudoscalar0 =new TProfile("helpseudoscalar0", "scalar; q^{2} (GeV^{2}); Helicity Amplitudes (GeV^{2})", nbins, 0,0.015, 0,0.6);
    auto  *helvector01D = new TH1D("helvector01D", "Pseudo Scalar helicity", nbins, 0.0, 0.60);
    auto  *helvector0 = new TProfile("helvector0", "Vector helicity", nbins, 0.0,0.0150,0,0.6 );
    auto  *helvector1 = new TProfile("helvector1", "Vector helicity", nbins, 0.0,0.0150,0, 0.6);
    auto  *helvectort = new TProfile("helvectort", "Vector helicity", nbins, 0.0,0.0150,0, 0.6);
    auto  *helaxvector0 = new TProfile("helaxvector0", "Axial Vector helicity", nbins, 0.0,0.0150,0, 0.6);
    auto  *helaxvector1 = new TProfile("helaxvector1", "Axial Vector helicity", nbins, 0.0,0.0150,0, 0.6);
    auto  *helaxvectort = new TProfile("helaxvectort", "Axial Vector helicity", nbins, 0.0,0.0150,0, 0.6);
    auto  *diffAsFq2 = new TProfile("diffAsFq2", "DecayWidth as Function of q^{2}; q^{2} (GeV); d#Gamma/dq^{2}dcos#theta", nbins, 0.0,0.0150,0,0.001);
    auto  *diffAsFthet = new TProfile("diffAsFthet", "DecayWidth as Function of #theta_{l}; #theta_{l} (rad); d#Gamma/dq^{2}dcos#theta", nbins, -TMath::Pi(),TMath::Pi(),0,pow(10,-17));
    auto  *AFBAsFq2 = new TProfile("AFBAsFq2", "FB asymmetry as Function of q^{2}; q^{2} (GeV); A_{FB}", nbins, 0.0,0.0150,0,0.020);
    auto  *ConAsFq2 = new TProfile("ConAsFq2", "Convexity parameter  as Function of q^{2}; q^{2} (GeV); Convexity", nbins, 0.0,0.0150,-0.5,0.5);
    auto  *HadPolAsFq2 = new TProfile("HadPolAsFq2", "Hadronic polarization  as Function of q^{2}; q^{2} (GeV); Hadronic Polarization", nbins, 0.0,0.0150,-0.5,0.5);
    auto  *BRFracAsFq2 = new TProfile("BRFracAsFq2", "BR fraction   as Function of q^{2}; q^{2} (GeV); BR", nbins, 0.0,0.0150,0, 1e-8);
    auto *polarhad = new TH1D("polarhad", "polarhad", nbins, 0.0, 1);
    auto *branfrac = new TH1D("branfrac", "branfrac", nbins, 0.0, 1e-8);
    auto *afbasymm = new TH1D("afbasymm", "afbasymm", nbins, 0.0, 1);
    auto *convexityhist = new TH1D("convexityhist", "convexityhist", nbins, 0.0, 1);
    
      for( Int_t i=0 ; i< 10000000; ++i){
          q2 = grandom->Gaus(0.0075,0.015);  //Gaus(mean,sigma)
        Qplus = (mxi+msigma)*(mxi+msigma) - q2;
        Qminus = (mxi-msigma)*(mxi-msigma) - q2;
        srQplus = sqrt(Qplus);
        srQminus = sqrt(Qminus);
//=================================================================================================================Helicity Amplitudes
        h120s = abs((real(sleft)+real(sright))*(srQplus/(msquark-mupquark))*((mxi-msigma)*f1V + (q2/mxi)*f3V));
        h120p = abs((real(sleft)-real(sright))*(srQminus/(msquark+mupquark))*(-(mxi+msigma)*f1A + (q2/mxi)*f3A));
        h120v = abs((1.0+real(gleft)+real(gright))*(srQminus/sqrt(q2))*((mxi+msigma)*f1V + (q2/mxi)*f2V));
        h121v = abs((1.0+real(gleft)+real(gright))*(sqrt(2.0)*srQminus)*(-f1V - ((mxi+msigma)/mxi)*f2V));
        h12tv = abs((1.0+real(gleft)+real(gright))*(srQplus/sqrt(q2))*((mxi-msigma)*f1V + (q2/mxi)*f3V));
        h120a = abs((1.0+real(gleft)-real(gright))*(srQplus/sqrt(q2))*(-(mxi-msigma)*f1A + (q2/mxi)*f2A));
        h121a = abs((1.0+real(gleft)-real(gright))*(sqrt(2.0)*srQplus)*(f1A - ((mxi-msigma)/mxi)*f2A));
        h12ta = abs((1.0+real(gleft)-real(gright))*(srQminus/sqrt(q2))*(-(mxi+msigma)*f1A + (q2/mxi)*f3A));
        modh121sq = (h121v+h121a)*(h121v+h121a);
        modhm121sq = (h121v-h121a)*(h121v-h121a);
        modh120sq = (h120v+h120a)*(h120v+h120a);
        modhm12tsq = (f1V+f1A)*(f1V+f1A);
        modh12tsq = (h12tv+h12ta)*(h12tv+h12ta);
          
          
          if(h120s != h120s)continue;
          if(h120p != h120p)continue;
          if(h120v != h120v)continue;
          if(h121v != h121v)continue;
          if(h12tv != h12tv)continue;
          if(h120a != h120a)continue;
          if(h121a != h121a)continue;
          if(h12ta != h12ta)continue;
          
//=====================================================================================================
          // Square and multiplication of helicity amplitudes
          // to calculate the actual amplitudes in described in the model
//====================================================================================
          
          
          hel_sq_1 = pow((h121v+h121a),2);
          hel_sq_2 = pow((h121v-h121a),2);
          hel_sq_3 = pow((h120v+h120a),2);
          hel_sq_4 = pow((h120v+h120a),2);
          hel_sq_5 = pow((h12tv+h12ta),2);
          hel_sq_6 = pow((h12tv+h12ta),2);
          hel_sq_7 = (h12tv+h12ta)*(h120v+h120a)+(h12tv+h12ta)*(h120v+h120a);
          hel_sq_8 = pow((h120s+h120p),2);
          hel_sq_9 = (h120v+h120a)*(h120s+h120p)+(h120v+h120a)*(h120s+h120p);
          hel_sq_10 = (h12tv+h12ta)*(h120s+h120p)+(h12tv+h12ta)*(h120s+h120p);
         
         
          Pol_Ang = grandom->Gaus(-0.785, 6.28);
          Ampli_1 = (1.0/4.0)*(((1+cos(Pol_Ang))*(1+cos(Pol_Ang))*hel_sq_1) + ((1-cos(Pol_Ang))*(1-cos(Pol_Ang))*hel_sq_2));
          Ampli_2 = (1.0/2.0)*sin(Pol_Ang)*(hel_sq_3+hel_sq_4);
          Ampli_3 = ((mlepton*mlepton)/(2.0*q2))*(hel_sq_5+hel_sq_6);
          Ampli_4 = ((mlepton*mlepton*sin(Pol_Ang)*sin(Pol_Ang))/(4.0*q2))*(hel_sq_1+hel_sq_2);
          Ampli_5 = ((mlepton*mlepton*cos(Pol_Ang)*cos(Pol_Ang))/(2.0*q2))*(hel_sq_3+hel_sq_4);
          Ampli_6 = -((mlepton*mlepton*cos(Pol_Ang)*cos(Pol_Ang))/(q2))*hel_sq_7;
          Ampli_7 = (2.0)*(hel_sq_8+hel_sq_8);
          Ampli_8 = -((4.0)*mlepton*cos(Pol_Ang)/(sqrt(q2)))*hel_sq_9;
          Ampli_9 = (((4.0)*mlepton)/(sqrt(q2)))*hel_sq_10;
          Total_Amplitude = Ampli_1+Ampli_2+Ampli_3+Ampli_4+Ampli_5+Ampli_6+Ampli_7+Ampli_8+Ampli_9;
          ConsTant_Factor = (fermi_G*fermi_G*CKM_V*CKM_V)/(pow(((2.0)*pi),3)*64.0*mxi*mxi);
          Diff_Decay_Width = ConsTant_Factor*(1.0/2.0*mxi)*sqrt(Qplus*Qminus)*(1-(mlepton*mlepton/q2))*(q2-mlepton*mlepton)*Total_Amplitude;
          
          
 //================================================================================
          // dGamma/dq2
          // Forward - Backward Asymmetry
          //===================================
          
          
          
          AFB_Amp_1 = (1.0/6.0)*(hel_sq_1+hel_sq_2);
          AFB_Amp_2 = (1.0/3.0)*(hel_sq_3 +hel_sq_4);
          AFB_Amp_3 = ((mlepton*mlepton)/(2.0*q2))*(hel_sq_5+hel_sq_6);
          AFB_Amp_4 = ((mlepton*mlepton*pi)/(16.0*q2))*(hel_sq_5+hel_sq_2);
          AFB_Amp_5 = ((mlepton*mlepton*2.0)/(6.0*q2))*(hel_sq_3+hel_sq_4);
          AFB_Amp_6 = ((mlepton*mlepton*2.0)/(3.0*q2))*(hel_sq_7);
          AFB_Amp_7 = 4.0*hel_sq_8;
          AFB_Amp_8 = ((8.0*mlepton)/sqrt(q2))*(hel_sq_10);
          AFB_Total_Amplitude = AFB_Amp_1+AFB_Amp_2+AFB_Amp_3+AFB_Amp_4+AFB_Amp_5+AFB_Amp_6+AFB_Amp_7+AFB_Amp_8;
          AFB_Numerator = (1.0/2.0)*(hel_sq_1-hel_sq_2)+((4.0*mlepton)/(sqrt(q2)))*(hel_sq_9);
          AFB_Denominator =AFB_Total_Amplitude;
          For_Back_Asymm = AFB_Numerator/AFB_Denominator;
          dGamma_Dq2 = ConsTant_Factor*(1/2.0*mxi)*sqrt(Qplus*Qminus)*(1-(mlepton*mlepton/q2))*(q2-mlepton*mlepton)*AFB_Total_Amplitude;
          afbasymm->Fill(For_Back_Asymm);
          lifetime =  decay->Exp(ctau);
          branfrac->Fill(dGamma_Dq2/lifetime);
          
//================================================================================================
          // Convexity parameter
          //====================================
          
          
          
          Convex_Amp_1 = (1.0/2.0)*(hel_sq_1+hel_sq_2);
          Convex_Amp_2 = -(1.0/2.0*pow(sin(Pol_Ang), 3))*(hel_sq_3 + hel_sq_4);
          Convex_Amp_3 = -(1.0*mlepton*mlepton/4.0*q2*pow(sin(Pol_Ang),3))*(hel_sq_1+hel_sq_2);
          Convex_Amp_4 = (mlepton*mlepton/q2)*(hel_sq_3+hel_sq_4);
          Convex_Amp_5 = -(2.0*mlepton*mlepton/q2)*(hel_sq_7);
          
          Convex_Total_Amplitude = Convex_Amp_1+Convex_Amp_2+Convex_Amp_3+Convex_Amp_4+Convex_Amp_5;
          Convexity_Parameter = Convex_Total_Amplitude/AFB_Denominator;
          convexityhist->Fill(Convexity_Parameter);
          
          
          //========================================================
          //Hadron Polarization
          //===================================
          
          
          
          Had_Pol_Amp_1 = ((1.0/6.0)*hel_sq_1) + ((1.0/3.0)*hel_sq_3) + ((mlepton*mlepton/2.0*q2)*hel_sq_5) + (((mlepton*mlepton*pi)/16.0*q2)*hel_sq_1);
          Had_Pol_Amp_2 = (((mlepton*mlepton*2.0)/(6.0*q2))*hel_sq_3) - (((mlepton*mlepton*2.0)/3.0*q2)*(h12tv+h12ta)*(h120v+h120a)) ;
          Had_Pol_Amp_3 = (4.0*hel_sq_8) + (((8.0*mlepton)/sqrt(q2))*(h120v+h120a)*(h120s+h120p)) ;
          
          Had_Pol_Amp_4 = ((1.0/6.0)*hel_sq_2) + ((1.0/3.0)*hel_sq_4) + ((mlepton*mlepton/2.0*q2)*hel_sq_6) + (((mlepton*mlepton*pi)/16.0*q2)*hel_sq_2);
          Had_Pol_Amp_5 = (((mlepton*mlepton*2.0)/(6.0*q2))*hel_sq_4) - (((mlepton*mlepton*2.0)/3.0*q2)*(h12tv+h12ta)*(h120v+h120a)) ;
          Had_Pol_Amp_6 = (4.0*hel_sq_8) + (((8.0*mlepton)/sqrt(q2))*(h12tv+h12ta)*(h120s+h120p)) ;
          
          Resultant_Had_Pol = (Had_Pol_Amp_1+Had_Pol_Amp_2+Had_Pol_Amp_3)-(Had_Pol_Amp_4+Had_Pol_Amp_5+Had_Pol_Amp_6);
          Hadronic_Polarization = (ConsTant_Factor*(1/2.0*mxi)*sqrt(Qplus*Qminus)*(1-(mlepton*mlepton/q2))*(q2-mlepton*mlepton)*Resultant_Had_Pol)/(dGamma_Dq2) ;
          polarhad->Fill(Hadronic_Polarization);
          
          
        helscalar0->Fill(q2,h120s,1);
        helpseudoscalar0->Fill(q2, h120p, 1);
        helvector0->Fill(q2, h120v, 1);
        helvector1->Fill(q2, h121v, 1);
        helvectort->Fill(q2, h12tv, 1);
        helaxvector0->Fill(q2, h120a, 1);
        helaxvector1->Fill(q2, h121a, 1);
        helaxvectort->Fill(q2, h12ta, 1);
        diffAsFq2->Fill(q2,Diff_Decay_Width,1);
        diffAsFthet->Fill(Pol_Ang,Diff_Decay_Width,1);
        AFBAsFq2->Fill(q2, For_Back_Asymm,1);
        ConAsFq2->Fill(q2, Convexity_Parameter,1);
        HadPolAsFq2->Fill(q2, Hadronic_Polarization,1);
        BRFracAsFq2->Fill(q2,(dGamma_Dq2/Mean_tau),1);
        
    }
    std::cout <<" Hadron polarization  : "<<polarhad->GetRMS()<<"pm"<<polarhad->GetRMSError()<<"\n";
    std::cout<<"Differential branching ratio:  "<<branfrac->GetRMS()<<"pm"<<branfrac->GetRMSError()<<"\n";
    std::cout<<"The value of the differential decay width costheta integrated:  "<<dGamma_Dq2<<"\n";
    std::cout<<"The value of the differential decay width:  "<<Diff_Decay_Width<<"\n";
    std::cout<<"Forward -Backward asymmetry:  "<<afbasymm->GetRMS()<<"pm"<<afbasymm->GetRMSError()<<"\n";
    std::cout<<"Convexity parameter"<<convexityhist->GetRMS()<<"pm"<<convexityhist->GetRMSError()<<"\n";
    TCanvas * c = new TCanvas();
    helvector0->Draw();
    helvector0->SetMarkerStyle(8);
    helvector0->SetMarkerColor(8);
    helvector1->Draw("same");
    helvector1->SetMarkerStyle(21);
    helvector1->SetMarkerColor(4);
    helvectort->Draw("same");
    helvectort->SetMarkerStyle(33);
    helvectort->SetMarkerColor(9);
    helaxvector0->Draw("same");
    helaxvector0->SetMarkerStyle(34);
    helaxvector0->SetMarkerColor(28);
    helaxvector1->Draw("same");
    helaxvector1->SetMarkerStyle(22);
    helaxvector1->SetMarkerColor(2);
    helaxvectort->Draw("same");
    helaxvectort->SetMarkerStyle(23);
    helaxvectort->SetMarkerColor(1);
    TLegend *legend = new TLegend(0.01,0.4,0.014,0.5);
    legend->AddEntry(helvector0, "H_{#frac{1}{2}0}^{V}");
    legend->AddEntry(helvector1, "H_{#frac{1}{2}1}^{V}");
    legend->AddEntry(helvectort, "H_{#frac{1}{2}t}^{V}");
    legend->AddEntry(helaxvector0, "H_{#frac{1}{2}0}^{A}");
    legend->AddEntry(helaxvector1, "H_{#frac{1}{2}1}^{A}");
    legend->AddEntry(helaxvectort, "H_{#frac{1}{2}t}^{A}");
    legend->Draw();
    TCanvas * c1 = new TCanvas();
    diffAsFq2->Draw();
    TCanvas * c2 = new TCanvas();
    gStyle->SetPalette(1);
    diffAsFthet->Draw();
    TCanvas * c3 = new TCanvas();
    AFBAsFq2->Draw();
    TCanvas * c4 = new TCanvas();
    ConAsFq2->Draw();
    TCanvas * c5 = new TCanvas();
    HadPolAsFq2->Draw();
    TCanvas * c6 = new TCanvas();
    BRFracAsFq2->Draw();
}
